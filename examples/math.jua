fn abs(n) = (n < 0) ? -n : n;

fn complex(r, i) = {
    r: r,
    i: i
};

fn complex_add(c1, c2) = complex(
    (c1.r + c2.r),
    (c1.i + c2.i)
);

fn complex_mul(c1, c2) = complex(
    (c1.r * c2.r - c1.i * c2.i),
    (c1.r * c2.i + c1.i * c2.r)
);

fn complex_div(c1, c2) = complex(
    (c1.r * c2.r + c1.i * c2.i) / (c2.r * c2.r + c2.i * c2.i),
    (c1.i * c2.r - c1.r * c2.i) / (c2.r * c2.r + c2.i * c2.i)
);

fn stringify_complex(z) = z.r + " + " + z.i + "i";

fn complex_equals(c1, c2) = (c1.r == c2.r) && (c1.i == c2.i);

fn complex_test(test_id) {
    switch test_id {
        case 1: {
            var a = complex(100.0, 10.0);
            var b = complex(0.0, 10.0);
            var c = complex_div(a, b);
            println(stringify_complex(c));
            var d = complex_mul(c, b);
            println(stringify_complex(d)); // 100 + 10i
        }
        case 2: {
            // r₁ / r₂ = r₁ * (1 / r₂)
            // z₁ / z₂ = z₁ * (1 / z₂)
            var a  = complex(44.0, 99.0);
            var b  = complex(4.0, 10.0);
            var c  = complex_div(
                complex(1.0, 0.0),
                b
            );
            println(stringify_complex(c));
            var d1 = complex_div(a, b);
            var d2 = complex_mul(a, c);
            // d1 should be equal to d2
            println(stringify_complex(d1));
            println(stringify_complex(d2));
        }
    }
}

fn int_fact(n) {
    var m = 1;
    for var i = n; i > 1; i-- {
        m *= i;
    }
    return m;
}

fn test_int_fact() {
    assert_eq(int_fact(0), 1,   "0!");
    assert_eq(int_fact(1), 1,   "1!");
    assert_eq(int_fact(2), 2,   "2!");
    assert_eq(int_fact(3), 6,   "3!");
    assert_eq(int_fact(4), 24,  "4!");
    assert_eq(int_fact(5), 120, "5"!");
}

const MATH_E = 2.718281828459045;
const MATH_PI = 3.141592653589793;
const MATH_TAU = MATH_PI * 2;

const _D2R = MATH_PI / 180;
const _R2D = 180 / MATH_PI;

fn rad(deg) = deg * _D2R;
fn deg(rad) = rad * _R2D;

fn int_pow(base, power) {
    var negative = false;
    if (power < 0) {
        negative = true;
        power = -power;
    }
    var result = 1.0;
    while (power > 0) {
        if ((power & 1) != 0) {
            result *= base;
        }
        base *= base;
        power >>= 1;
    }
    return negative ? 1.0 / result : result;
}

fn test_int_pow() {
    assert_eq(int_pow(0, 0),  1,    "0^0");
    assert_eq(int_pow(0, 1),  1,    "0^1");
    assert_eq(int_pow(1, 2),  1,    "1^2");
    assert_eq(int_pow(2, 3),  1,    "2^3");
    assert_eq(int_pow(2, -2), 0.25, "2^-2");
}

fn cos(x) {
    var result = 0;
    for var i = 0; i < 7; i++ {
        result += int_pow(-1, i) * int_pow(x, 2 * i) / int_fact(2 * i);
    }
    return result;
}

fn sin(x) {
    var result = 0;
    for var i = 0; i < 7; i++ {
        result += int_pow(-1, i) * int_pow(x, 2 * i + 1) / int_fact(2 * i + 1);
    }
    return result;
}