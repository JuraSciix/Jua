const OPCODE_NOP    = 0;
const OPCODE_PUSH   = 1;
const OPCODE_LOAD   = 2;
const OPCODE_STORE  = 3;
const OPCODE_CONST  = 4;
const OPCODE_ADD    = 5;
const OPCODE_SUB    = 6;
const OPCODE_MUL    = 7;
const OPCODE_DIV    = 8;
const OPCODE_INC    = 9;
const OPCODE_DEC    = 10;
const OPCODE_IFGT   = 11;
const OPCODE_IFGE   = 12;
const OPCODE_IFLT   = 13;
const OPCODE_IFLE   = 14;
const OPCODE_IFEQ   = 15;
const OPCODE_IFNE   = 16;
const OPCODE_GOTO   = 17;
const OPCODE_PRINT  = 18;
const OPCODE_RETURN = 19;

fn interpret(program) {
    var code = program.code;
    var pc = 0;
    var stack = list(program.stack_size ?? 0xff);
    var sp = 0;
    var slots = list(program.slots_count ?? 0xff);
    var cp = program.constant_pool ?? [];

    while true {
        //println(pc + ': ' + code[pc]);
        switch code[pc] {
            case OPCODE_NOP: {
                pc++;
                continue;
            }

            case OPCODE_PUSH: {
                stack[sp] = code[pc + 1];
                sp++;
                pc += 2;
                continue;
            }

            case OPCODE_LOAD: {
                stack[sp] = slots[code[pc + 1]];
                sp++;
                pc += 2;
                continue;
            }

            case OPCODE_STORE: {
                slots[code[pc + 1]] = stack[sp - 1];
                sp--;
                pc += 2;
                continue;
            }

            case OPCODE_CONST: {
                stack[sp] = cp[code[pc + 1]];
                sp++;
                pc += 2;
                continue;
            }

            case OPCODE_ADD: {
                stack[sp - 2] += stack[sp - 1];
                sp--;
                pc++;
                continue;
            }

            case OPCODE_SUB: {
                stack[sp - 2] -= stack[sp - 1];
                sp--;
                pc++;
                continue;
            }

            case OPCODE_MUL: {
                stack[sp - 2] *= stack[sp - 1];
                sp--;
                pc++;
                continue;
            }

            case OPCODE_DIV: {
                stack[sp - 2] /= stack[sp - 1];
                sp--;
                pc++;
                continue;
            }

            case OPCODE_INC: {
                slots[code[pc + 1]]++;
                pc += 2;
                continue;
            }

            case OPCODE_DEC: {
                slots[code[pc + 1]]--;
                pc += 2;
                continue;
            }

            case OPCODE_IFGT: {
                if stack[sp - 2] > stack[sp - 1] {
                    sp -= 2;
                    pc = code[pc + 1];
                } else {
                    sp -= 2;
                    pc += 2;
                }
                continue;
            }

            case OPCODE_IFGE: {
                if stack[sp - 2] >= stack[sp - 1] {
                    sp -= 2;
                    pc = code[pc + 1];
                } else {
                    sp -= 2;
                    pc += 2;
                }
                continue;
            }

            case OPCODE_IFLT: {
                if stack[sp - 2] < stack[sp - 1] {
                    sp -= 2;
                    pc = code[pc + 1];
                } else {
                    sp -= 2;
                    pc += 2;
                }
                continue;
            }

            case OPCODE_IFLE: {
                if stack[sp - 2] <= stack[sp - 1] {
                    sp -= 2;
                    pc = code[pc + 1];
                } else {
                    sp -= 2;
                    pc += 2;
                }
                continue;
            }

            case OPCODE_IFEQ: {
                if stack[sp - 2] == stack[sp - 1] {
                    sp -= 2;
                    pc = code[pc + 1];
                } else {
                    sp -= 2;
                    pc += 2;
                }
                continue;
            }

            case OPCODE_IFNE: {
                if stack[sp - 2] != stack[sp - 1] {
                    sp -= 2;
                    pc = code[pc + 1];
                } else {
                    sp -= 2;
                    pc += 2;
                }
                continue;
            }

            case OPCODE_GOTO: {
                pc = code[pc + 1];
                continue;
            }

            case OPCODE_PRINT: {
                println(stack[sp - 1]);
                sp--;
                pc++;
                continue;
            }

            case OPCODE_RETURN: {
                var result = stack[sp - 1];
                sp--;
                pc++;
                return result;
            }

            default: {
                println("invalid opcode: " + code[pc] + "(pc=" + pc + ",sp=" + sp + ")");
                return null;
            }
        }
    }
}

// Эта программа вычисляет факториал числа из пула констант и выводит в консоль.
var program1 = {
    constant_pool: [10], // 3628800
    code: [
        /*  0 */ OPCODE_CONST,
        /*  1 */ 0,
        /*  2 */ OPCODE_STORE,
        /*  3 */ 0,
        /*  4 */ OPCODE_PUSH,
        /*  5 */ 1,
        /*  6 */ OPCODE_STORE,
        /*  7 */ 1,
        /*  8 */ OPCODE_GOTO,
        /*  9 */ 18,
        /* 10 */ OPCODE_LOAD,
        /* 11 */ 1,
        /* 12 */ OPCODE_LOAD,
        /* 13 */ 0,
        /* 14 */ OPCODE_MUL,
        /* 15 */ OPCODE_STORE,
        /* 16 */ 1,
        /* 17 */ OPCODE_DEC,
        /* 18 */ 0,
        /* 19 */ OPCODE_LOAD,
        /* 20 */ 0,
        /* 21 */ OPCODE_PUSH,
        /* 22 */ 1,
        /* 23 */ OPCODE_IFGT,
        /* 24 */ 10,
        /* 25 */ OPCODE_LOAD,
        /* 26 */ 1,
        /* 27 */ OPCODE_PRINT,
        /* 28 */ OPCODE_PUSH,
        /* 29 */ 0,
        /* 30 */ OPCODE_RETURN,
    ]
};

interpret(program1);
